# Stateless vs Stateful Systems in System Design


## 1. What is a Stateless System?

* A **stateless system** does not remember anything about the client after serving a request.
* Each request is **independent** and must carry **all the data** required for processing.
* Example: **REST APIs**, **Serverless functions (AWS Lambda)**.

ðŸ“Œ **Analogy**: Think of a **fast-food counter** (like McDonald's drive-thru).
Every time you order, you must tell them **exactly what you want**, even if you ordered the same burger yesterday. They donâ€™t remember you.

---

## 2. What is a Stateful System?

* A **stateful system** maintains the clientâ€™s information across requests.
* The system remembers things like **login sessions, carts, preferences**.
* Example: **Databases, User Sessions, Chat applications**.

ðŸ“Œ **Analogy**: Think of a **restaurant waiter**.
The waiter remembers your table, what you ordered, and can bring your food step by step. You donâ€™t repeat everything each time.

---

## 3. Diagram Representation


---

## 4. Real-World Examples

| System Type | Example                                                                   |
| ----------- | ------------------------------------------------------------------------- |
| Stateless   | REST API, AWS Lambda, Content Delivery Networks (CDN), JWT Authentication |
| Stateful    | Databases, Web App Sessions, Online Gaming, Messaging Apps                |

---

## 5. Code Examples

### (A) Stateless Example: REST API with Token

```cpp
#include <iostream>
#include <string>
using namespace std;

// Stateless request simulation
class StatelessAPI {
public:
    string processRequest(string request, string token) {
        if (token != "valid123") return "Unauthorized";
        return "Processed: " + request;
    }
};

int main() {
    StatelessAPI api;

    // Each request must carry the token (no memory of previous requests)
    cout << api.processRequest("Get User Data", "valid123") << endl;
    cout << api.processRequest("Update Profile", "invalid") << endl;

    return 0;
}
```

**Output:**

```
Processed: Get User Data
Unauthorized
```

ðŸ‘‰ Here, the server does **not remember** who you are â€” you must prove it every time (stateless).

---

### ðŸ”Ž Code Walkthrough (Stateless API)

1. **Class design**

```cpp
class StatelessAPI {
public:
    string processRequest(string request, string token) {
        if (token != "valid123") return "Unauthorized";
        return "Processed: " + request;
    }
};
```

* This class has **no data members** (no `sessions` map like before).
* It doesnâ€™t store anything between calls.
* Each request must carry a **token** â†’ like an API key, JWT, or session token.
* Server only checks the token â†’ decides request validity â†’ responds.

---

2. **First request**

```cpp
cout << api.processRequest("Get User Data", "valid123") << endl;
```

* `token = "valid123"` âœ… â†’ authorized.
* Returns:

```
Processed: Get User Data
```

---

3. **Second request**

```cpp
cout << api.processRequest("Update Profile", "invalid") << endl;
```

* `token = "invalid"` âŒ â†’ unauthorized.
* Returns:

```
Unauthorized
```

---

### âš–ï¸ Comparison with Stateful Server

| Aspect                 | Stateful                           | Stateless                                 |
| ---------------------- | ---------------------------------- | ----------------------------------------- |
| **Memory**             | Stores `sessions[user]`            | Stores nothing                            |
| **After logout**       | User is forgotten                  | No logout needed â€” must always send token |
| **Request dependency** | Request depends on previous login  | Every request is independent              |
| **Example**            | Facebook session with login/logout | REST API with API key or JWT              |

---

### âœ… Why is this Stateless?

Because the server **does not remember Alice at all**.

* No `sessions` map.
* Each request is judged **only on the token provided at that moment**.
* No continuity, no "history".

---

### (B) Stateful Example: Session Tracking

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

// Stateful session simulation
class StatefulServer {
    unordered_map<string, string> sessions; // user -> sessionData
public:
    void login(string user) {
        sessions[user] = "SessionActive";
        cout << user << " logged in.\n";
    }
    void action(string user, string task) {
        if (sessions.find(user) != sessions.end())
            cout << user << " performed: " << task << endl;
        else
            cout << "No active session for " << user << endl;
    }
    void logout(string user) {
        sessions.erase(user);
        cout << user << " logged out.\n";
    }
};

int main() {
    StatefulServer server;
    server.login("Alice");
    server.action("Alice", "View Profile");
    server.logout("Alice");
    server.action("Alice", "Update Profile"); // Fails, session ended
}
```

**Output:**

```
Alice logged in.
Alice performed: View Profile
Alice logged out.
No active session for Alice
```

ðŸ‘‰ Here, the server **remembers Aliceâ€™s session** until logout.

Great question ðŸ‘ Letâ€™s carefully walk through your code and output to understand **why the last action fails**.

---

### ðŸ”Ž Code Walkthrough

1. **Login Alice**

```cpp
server.login("Alice");
```

* This inserts `"Alice" â†’ "SessionActive"` into the `sessions` map.
* Now `sessions = { "Alice" : "SessionActive" }`.
* Output:

```
Alice logged in.
```

---

2. **Action: View Profile**

```cpp
server.action("Alice", "View Profile");
```

* The code checks:

```cpp
if (sessions.find("Alice") != sessions.end())
```

âœ… Since `"Alice"` exists in the `sessions` map, it prints:

```
Alice performed: View Profile
```

---

3. **Logout Alice**

```cpp
server.logout("Alice");
```

* This line:

```cpp
sessions.erase("Alice");
```

removes Aliceâ€™s session from the map.

* Now `sessions = { }` (empty).
* Output:

```
Alice logged out.
```

---

4. **Action: Update Profile (after logout)**

```cpp
server.action("Alice", "Update Profile");
```

* The code checks again:

```cpp
if (sessions.find("Alice") != sessions.end())
```

âŒ This time `"Alice"` does **not exist** in the map (because she logged out).

* So it goes to the `else` branch:

```
No active session for Alice
```

---

### âœ… Why does it fail?

Because the `StatefulServer` class **removes Aliceâ€™s session data on logout**. After logging out, the server no longer remembers Alice. So when she tries to perform `"Update Profile"`, the server says:
ðŸ‘‰ *"No active session for Alice"*

This is exactly how **stateful systems work** in real life:

* When you **log out** of Facebook and try to refresh your profile, the server doesnâ€™t let you because your **session expired**.

---

âš¡ In short:

* Before logout â†’ server remembers Alice â†’ actions succeed.
* After logout â†’ server forgets Alice â†’ actions fail.

---

## 6. When to Use What?

| Factor               | Stateless                        | Stateful                    |
| -------------------- | -------------------------------- | --------------------------- |
| **Scalability**      | âœ… Easy (just add servers)        | âŒ Hard (need to sync state) |
| **Performance**      | âœ… Fast (lightweight)             | âš ï¸ Slower (session mgmt)    |
| **Use Case**         | APIs, CDNs, Authentication       | Games, Banking, Chats       |
| **Failure Handling** | âœ… Easy (route to another server) | âŒ Hard (must recover state) |

---

## 7. Hybrid Approach (Best in Real World)

Most real-world systems use a **mix of stateless + stateful**:

* **Frontend**: Stateless (e.g., REST API, load balanced servers).
* **Backend**: Stateful (e.g., database, caching session info).
* Example:

  * Amazon shopping: browsing is **stateless**, but your **cart** is **stateful**.
  * Google Docs: editing is **stateful**, but serving static assets is **stateless**.

---

## 8. Key Takeaways

* **Stateless** â†’ Simpler, more scalable, resilient.
* **Stateful** â†’ Needed for personalization, consistency, multi-step workflows.
* **Best Systems** â†’ Combine both depending on context.

**